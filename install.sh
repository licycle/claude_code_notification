#!/bin/sh
set -e

# ================= Configuration =================
APP_NAME="ClaudeMonitor"
INSTALL_DIR="$HOME/Applications/$APP_NAME.app"
BINARY_PATH="$INSTALL_DIR/Contents/MacOS/$APP_NAME"
BASE_DIR="$HOME/.claude-hooks"
TRACKER_DIR="$BASE_DIR/task_tracker"
CONFIG_FILE="$BASE_DIR/config.sh"
API_MANAGER_SCRIPT="$BASE_DIR/api_manager.py"
ACCOUNT_MANAGER_SCRIPT="$BASE_DIR/account_manager.py"
PY_LOG="$BASE_DIR/python_debug.log"
SWIFT_LOG="$BASE_DIR/swift_debug.log"
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

# Task Tracker is always installed (unified architecture)

GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

cecho() { printf "%b\n" "$1"; }

# ================= Quick Hooks Update Mode =================
if [ "$1" = "--hooks-only" ] || [ "$1" = "-p" ]; then
    cecho "${BLUE}=== Quick Hooks Update ===${NC}"

    TRACKER_SRC="$SCRIPT_DIR/python/task_tracker"

    if [ ! -d "$TRACKER_SRC" ]; then
        cecho "${RED}‚ùå Error: Task Tracker source not found at $TRACKER_SRC${NC}"
        exit 1
    fi

    # Update hook scripts
    cecho "${YELLOW}Updating hook scripts...${NC}"
    cp "$TRACKER_SRC/hooks/utils.py" "$TRACKER_DIR/hooks/"
    cp "$TRACKER_SRC/hooks/goal_tracker.py" "$TRACKER_DIR/hooks/"
    cp "$TRACKER_SRC/hooks/progress_tracker.py" "$TRACKER_DIR/hooks/"
    cp "$TRACKER_SRC/hooks/notification_tracker.py" "$TRACKER_DIR/hooks/"
    cp "$TRACKER_SRC/hooks/snapshot_hook.py" "$TRACKER_DIR/hooks/"
    cp "$TRACKER_SRC/hooks/session_cleanup.py" "$TRACKER_DIR/hooks/"
    cp "$TRACKER_SRC/hooks/session_init.py" "$TRACKER_DIR/hooks/"
    cp "$TRACKER_SRC/hooks/__init__.py" "$TRACKER_DIR/hooks/" 2>/dev/null || true
    chmod +x "$TRACKER_DIR/hooks/"*.py

    # Update service modules
    cecho "${YELLOW}Updating service modules...${NC}"
    cp "$TRACKER_SRC/services/database.py" "$TRACKER_DIR/services/"
    cp "$TRACKER_SRC/services/summary_service.py" "$TRACKER_DIR/services/"
    cp "$TRACKER_SRC/services/notification.py" "$TRACKER_DIR/services/"
    cp "$TRACKER_SRC/services/notification_formatter.py" "$TRACKER_DIR/services/"
    cp "$TRACKER_SRC/services/__init__.py" "$TRACKER_DIR/services/" 2>/dev/null || true
    cp "$TRACKER_SRC/__init__.py" "$TRACKER_DIR/" 2>/dev/null || true

    # Update shell wrapper function in config.sh
    cecho "${YELLOW}Updating shell wrapper...${NC}"
    if [ -f "$CONFIG_FILE" ]; then
        # Extract existing aliases from config.sh
        EXISTING_ALIASES=$(grep "^alias " "$CONFIG_FILE" 2>/dev/null || true)

        # Regenerate config.sh with updated wrapper
        cat << 'WRAPPER_EOF' > "$CONFIG_FILE"
# Claude Monitor Configuration
# Auto-generated by install.sh

_CLAUDE_MON_APP="$HOME/Applications/ClaudeMonitor.app/Contents/MacOS/ClaudeMonitor"
_CLAUDE_API_MANAGER="$HOME/.claude-hooks/api_manager.py"
_CLAUDE_ACCOUNT_MANAGER="$HOME/.claude-hooks/account_manager.py"
_CLAUDE_HOOKS_DIR="$HOME/.claude-hooks"

# --- API Management Command ---
function claude-api() {
    python3 "$_CLAUDE_API_MANAGER" "$@"
}

# --- Account Management Command ---
function claude-ac() {
    python3 "$_CLAUDE_ACCOUNT_MANAGER" "$@"
    if [ "$1" = "add" ] || [ "$1" = "rm" ]; then
        echo "üí° Run: source ~/.zshrc to apply changes"
    fi
}

# --- Core Smart Wrapper ---
_claude_wrapper() {
    local account_alias="$1"
    local config_path="$2"
    shift 2

    # 1. Detect Window IMMEDIATELY (before any processing)
    local detected_info=$("$_CLAUDE_MON_APP" detect 2>/dev/null)
    local detected_bundle=$(echo "$detected_info" | cut -d'|' -f1)
    local detected_pid=$(echo "$detected_info" | cut -d'|' -f2)
    local detected_window_id=$(echo "$detected_info" | cut -d'|' -f3)

    # 2. Generate pending session ID (UUID)
    local pending_id=$(uuidgen | tr '[:upper:]' '[:lower:]')

    # 3. Parse Arguments
    local -a claude_args
    local api_profile=""

    while [[ $# -gt 0 ]]; do
        key="$1"
        case $key in
            --api)
                api_profile="$2"
                shift 2
                ;;
            --api=*)
                api_profile="${key#*=}"
                shift 1
                ;;
            *)
                claude_args+=("$1")
                shift 1
                ;;
        esac
    done

    # 4. Execute in Subshell (API env isolation only)
    (
        if [ -n "$api_profile" ]; then
            eval "$(python3 "$_CLAUDE_API_MANAGER" get-env "$api_profile")"
            echo "üöÄ API Profile Active: $api_profile"
        fi

        export CLAUDE_TERM_BUNDLE_ID="${detected_bundle:-com.apple.Terminal}"
        export CLAUDE_TERM_PID="${detected_pid:-0}"
        export CLAUDE_CG_WINDOW_ID="${detected_window_id:-0}"
        export CLAUDE_CONFIG_DIR="$config_path"
        export CLAUDE_ACCOUNT_ALIAS="$account_alias"
        export CLAUDE_PENDING_SESSION_ID="$pending_id"

        # Create pending session BEFORE starting Claude (shows 'idle' in status bar)
        python3 "$_CLAUDE_HOOKS_DIR/task_tracker/hooks/session_init.py" 2>/dev/null

        command claude "${claude_args[@]}"
    )

    # 5. Cleanup on exit (handles ctrl+c and normal exit)
    # Pass pending_id as argument to only cleanup this specific session
    (set +m; python3 "$_CLAUDE_HOOKS_DIR/task_tracker/hooks/session_cleanup.py" "$pending_id" >/dev/null 2>&1 &)
}

# --- User Aliases ---
WRAPPER_EOF

        # Append existing aliases
        if [ -n "$EXISTING_ALIASES" ]; then
            echo "$EXISTING_ALIASES" >> "$CONFIG_FILE"
        fi
        cecho "${GREEN}‚úÖ Shell wrapper updated${NC}"
    else
        cecho "${YELLOW}‚ö†Ô∏è config.sh not found, run full install${NC}"
    fi

    cecho "${GREEN}‚úÖ Hooks updated${NC}"
    cecho "   Source: ${BLUE}$TRACKER_SRC${NC}"
    cecho "   Target: ${BLUE}$TRACKER_DIR${NC}"
    exit 0
fi

# ================= Quick App Rebuild Mode =================
if [ "$1" = "--app-only" ] || [ "$1" = "-a" ]; then
    cecho "${BLUE}=== Quick App Rebuild ===${NC}"

    # Kill existing app (more reliable)
    cecho "${YELLOW}Stopping existing processes...${NC}"
    pkill -9 -f "$APP_NAME" 2>/dev/null || true
    sleep 1  # Wait for process to fully exit

    # Verify process stopped
    if pgrep -f "$APP_NAME" >/dev/null 2>&1; then
        cecho "${YELLOW}Process still running, retrying...${NC}"
        pkill -9 -f "$APP_NAME" 2>/dev/null || true
        sleep 1
    fi

    # Remove old binary
    rm -rf "$INSTALL_DIR"
    mkdir -p "$INSTALL_DIR/Contents/MacOS"
    mkdir -p "$INSTALL_DIR/Contents/Resources"

    # Compile Swift
    SWIFT_DIR="$SCRIPT_DIR/swift"
    cecho "${YELLOW}Compiling Swift...${NC}"
    swiftc \
        "$SWIFT_DIR/Utils/Logger.swift" \
        "$SWIFT_DIR/Utils/PermissionManager.swift" \
        "$SWIFT_DIR/Services/DatabaseManager.swift" \
        "$SWIFT_DIR/UI/StatusBarController.swift" \
        "$SWIFT_DIR/Core/AppDelegate.swift" \
        "$SWIFT_DIR/UI/SettingsWindow.swift" \
        "$SWIFT_DIR/Core/Main.swift" \
        -o "$BINARY_PATH" \
        -target arm64-apple-macosx12.0
    chmod +x "$BINARY_PATH"

    # Copy icon
    ASSETS_DIR="$SCRIPT_DIR/assets"
    [ -f "$ASSETS_DIR/app_icon.png" ] && cp "$ASSETS_DIR/app_icon.png" "$INSTALL_DIR/Contents/Resources/"
    [ -f "$ASSETS_DIR/AppIcon.icns" ] && cp "$ASSETS_DIR/AppIcon.icns" "$INSTALL_DIR/Contents/Resources/"

    # Create Info.plist
    cat << EOF > "$INSTALL_DIR/Contents/Info.plist"
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleIdentifier</key>
    <string>com.custom.claude.monitor</string>
    <key>CFBundleName</key>
    <string>$APP_NAME</string>
    <key>CFBundlePackageType</key>
    <string>APPL</string>
    <key>LSUIElement</key>
    <true/>
    <key>NSAppleEventsUsageDescription</key>
    <string>ClaudeMonitor needs automation access to restore minimized windows.</string>
    <key>CFBundleIconFile</key>
    <string>AppIcon.icns</string>
</dict>
</plist>
EOF

    # Sign and register
    codesign --force --deep --sign - "$INSTALL_DIR"
    cecho "${YELLOW}Registering with Notification Center...${NC}"
    open "$INSTALL_DIR"
    sleep 1.5  # Wait for registration to complete
    pkill -f "$APP_NAME" 2>/dev/null || true
    sleep 0.5  # Ensure process exits

    # Verify installation
    if [ -x "$BINARY_PATH" ]; then
        cecho "${GREEN}‚úÖ App rebuilt and installed${NC}"
        cecho "   Binary: ${GREEN}$BINARY_PATH${NC}"
        cecho "   Test:   ${GREEN}$BINARY_PATH gui${NC}"
    else
        cecho "${RED}‚ùå Installation failed - binary not found${NC}"
        exit 1
    fi
    exit 0
fi

# Function to generate hooks configuration in settings.json
# Unified Task Tracker architecture
generate_hooks_config() {
    local config_dir=$1
    local settings_file="$config_dir/settings.json"

    mkdir -p "$config_dir"

    SETTINGS_FILE="$settings_file" \
    BASE_DIR="$BASE_DIR" \
    python3 << 'PYEOF'
import os
import json

settings_file = os.environ['SETTINGS_FILE']
base_dir = os.environ['BASE_DIR']

# Task Tracker hooks (unified architecture)
tracker_goal_hook = f"{base_dir}/task_tracker/hooks/goal_tracker.py"
tracker_progress_hook = f"{base_dir}/task_tracker/hooks/progress_tracker.py"
tracker_notification_hook = f"{base_dir}/task_tracker/hooks/notification_tracker.py"
tracker_snapshot_hook = f"{base_dir}/task_tracker/hooks/snapshot_hook.py"

hooks_config = {
    "UserPromptSubmit": [
        {
            "hooks": [{"type": "command", "command": f"python3 {tracker_goal_hook}", "timeout": 5}]
        }
    ],
    "PostToolUse": [
        {
            "matcher": "TodoWrite|AskUserQuestion",
            "hooks": [{"type": "command", "command": f"python3 {tracker_progress_hook}", "timeout": 5}]
        }
    ],
    "Notification": [
        {
            "hooks": [{"type": "command", "command": f"python3 {tracker_notification_hook}", "timeout": 10}]
        }
    ],
    "Stop": [
        {
            "hooks": [
                {"type": "command", "command": f"python3 {tracker_snapshot_hook}", "timeout": 30}
            ]
        }
    ]
}

try:
    # Load existing settings or create new
    if os.path.exists(settings_file):
        with open(settings_file, 'r') as f:
            settings = json.load(f)
        action = "Updated"
    else:
        settings = {"$schema": "https://json.schemastore.org/claude-code-settings.json"}
        action = "Created"

    # Merge hooks config
    settings['hooks'] = hooks_config

    # Write back
    with open(settings_file, 'w') as f:
        json.dump(settings, f, indent=2)

    print(f"‚úÖ {action} hooks configuration in {settings_file}")
    exit(0)
except Exception as e:
    print(f"‚ùå Error: {e}")
    exit(1)
PYEOF
    return $?
}

cecho "${BLUE}=== Claude Monitor Pro Installer ===${NC}"

# ================= 0. Cleanup Old Versions =================
if [ -d "$INSTALL_DIR" ]; then
    cecho "${YELLOW}[!] Cleaning up previous installation...${NC}"
    rm -rf "$INSTALL_DIR"
fi
rm -f "$PY_LOG" "$SWIFT_LOG"
mkdir -p "$BASE_DIR"

# ================= 1. Build Swift Core Application =================
cecho "${YELLOW}[1/7] Compiling Swift Core...${NC}"
mkdir -p "$INSTALL_DIR/Contents/MacOS"

SWIFT_DIR="$SCRIPT_DIR/swift"
SWIFT_FILES="Utils/Logger.swift Utils/PermissionManager.swift Services/DatabaseManager.swift UI/StatusBarController.swift Core/AppDelegate.swift UI/SettingsWindow.swift Core/Main.swift"

for swiftfile in $SWIFT_FILES; do
    if [ ! -f "$SWIFT_DIR/$swiftfile" ]; then
        cecho "${RED}Error: $swiftfile not found in $SWIFT_DIR${NC}"
        exit 1
    fi
done

swiftc \
    "$SWIFT_DIR/Utils/Logger.swift" \
    "$SWIFT_DIR/Utils/PermissionManager.swift" \
    "$SWIFT_DIR/Services/DatabaseManager.swift" \
    "$SWIFT_DIR/UI/StatusBarController.swift" \
    "$SWIFT_DIR/Core/AppDelegate.swift" \
    "$SWIFT_DIR/UI/SettingsWindow.swift" \
    "$SWIFT_DIR/Core/Main.swift" \
    -o "$BINARY_PATH" \
    -target arm64-apple-macosx12.0
chmod +x "$BINARY_PATH"

# Create Resources directory (for app icon)
mkdir -p "$INSTALL_DIR/Contents/Resources"

# Copy app icon if it exists (from assets/ directory)
ASSETS_DIR="$SCRIPT_DIR/assets"
if [ -f "$ASSETS_DIR/app_icon.png" ]; then
    cp "$ASSETS_DIR/app_icon.png" "$INSTALL_DIR/Contents/Resources/app_icon.png"
    cecho "${GREEN}‚úÖ App icon copied${NC}"
else
    cecho "${YELLOW}[!] No app_icon.png found in assets/, skipping icon installation${NC}"
fi

# Copy .icns icon if it exists, or create it
if [ -f "$ASSETS_DIR/AppIcon.icns" ]; then
    cp "$ASSETS_DIR/AppIcon.icns" "$INSTALL_DIR/Contents/Resources/"
    cecho "${GREEN}‚úÖ .icns icon installed${NC}"
elif command -v iconutil >/dev/null 2>&1 && [ -f "$ASSETS_DIR/app_icon.png" ]; then
    # Create .icns from png if not exists
    mkdir -p "$ASSETS_DIR/AppIcon.iconset"
    sips -z 16 16 "$ASSETS_DIR/app_icon.png" --out "$ASSETS_DIR/AppIcon.iconset/icon_16x16.png" >/dev/null 2>&1
    sips -z 32 32 "$ASSETS_DIR/app_icon.png" --out "$ASSETS_DIR/AppIcon.iconset/icon_16x16@2x.png" >/dev/null 2>&1
    sips -z 32 32 "$ASSETS_DIR/app_icon.png" --out "$ASSETS_DIR/AppIcon.iconset/icon_32x32.png" >/dev/null 2>&1
    sips -z 64 64 "$ASSETS_DIR/app_icon.png" --out "$ASSETS_DIR/AppIcon.iconset/icon_32x32@2x.png" >/dev/null 2>&1
    sips -z 128 128 "$ASSETS_DIR/app_icon.png" --out "$ASSETS_DIR/AppIcon.iconset/icon_128x128.png" >/dev/null 2>&1
    sips -z 256 256 "$ASSETS_DIR/app_icon.png" --out "$ASSETS_DIR/AppIcon.iconset/icon_128x128@2x.png" >/dev/null 2>&1
    sips -z 256 256 "$ASSETS_DIR/app_icon.png" --out "$ASSETS_DIR/AppIcon.iconset/icon_256x256.png" >/dev/null 2>&1
    sips -z 512 512 "$ASSETS_DIR/app_icon.png" --out "$ASSETS_DIR/AppIcon.iconset/icon_256x256@2x.png" >/dev/null 2>&1
    sips -z 512 512 "$ASSETS_DIR/app_icon.png" --out "$ASSETS_DIR/AppIcon.iconset/icon_512x512.png" >/dev/null 2>&1
    sips -z 1024 1024 "$ASSETS_DIR/app_icon.png" --out "$ASSETS_DIR/AppIcon.iconset/icon_512x512@2x.png" >/dev/null 2>&1

    if iconutil -c icns "$ASSETS_DIR/AppIcon.iconset" -o "$ASSETS_DIR/AppIcon.icns" 2>/dev/null; then
        cp "$ASSETS_DIR/AppIcon.icns" "$INSTALL_DIR/Contents/Resources/"
        cecho "${GREEN}‚úÖ .icns icon created and installed${NC}"
    fi
fi

# Create Info.plist
cat << EOF > "$INSTALL_DIR/Contents/Info.plist"
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleIdentifier</key>
    <string>com.custom.claude.monitor</string>
    <key>CFBundleName</key>
    <string>$APP_NAME</string>
    <key>CFBundlePackageType</key>
    <string>APPL</string>
    <key>LSUIElement</key>
    <true/>
    <key>NSAppleEventsUsageDescription</key>
    <string>ClaudeMonitor needs automation access to restore minimized windows.</string>
    <key>CFBundleIconFile</key>
    <string>AppIcon.icns</string>
</dict>
</plist>
EOF

cecho "${GREEN}‚úÖ Swift Core compiled${NC}"

# ================= 2. Registration & Signing =================
cecho "${YELLOW}[2/7] Signing and Registering App...${NC}"
codesign --force --deep --sign - "$INSTALL_DIR"
open "$INSTALL_DIR"
sleep 0.5
pkill -f "$APP_NAME" || true
cecho "${GREEN}‚úÖ App Registered with macOS Notification Center${NC}"

# ================= 3. Install Scripts =================
cecho "${YELLOW}[3/7] Installing Managers...${NC}"

# CLI tools are now in python/task_tracker/cli/
CLI_SRC="$SCRIPT_DIR/python/task_tracker/cli"

# Check required Python files
for pyfile in api_manager.py account_manager.py; do
    if [ ! -f "$CLI_SRC/$pyfile" ]; then
        cecho "${RED}‚ùå Error: $pyfile not found in $CLI_SRC/${NC}"
        exit 1
    fi
done

# Copy CLI Python scripts
cp "$CLI_SRC/api_manager.py" "$API_MANAGER_SCRIPT"
cp "$CLI_SRC/account_manager.py" "$ACCOUNT_MANAGER_SCRIPT"

chmod +x "$BASE_DIR/"*.py
cecho "${GREEN}‚úÖ Scripts installed${NC}"

# ================= 3.5 Task Tracker Installation =================
cecho "\n${BLUE}--- Installing Task Tracker ---${NC}"
cecho "Task Tracker provides:"
cecho "  ‚Ä¢ ${GREEN}Progress tracking${NC} - Track todo completion"
cecho "  ‚Ä¢ ${GREEN}Goal tracking${NC} - Remember your original goals"
cecho "  ‚Ä¢ ${GREEN}Rich notifications${NC} - Detailed notifications with context"
cecho "  ‚Ä¢ ${GREEN}Session snapshots${NC} - Task summaries (optional AI)"
echo ""

# Check Task Tracker source files exist
TRACKER_SRC="$SCRIPT_DIR/python/task_tracker"
if [ ! -d "$TRACKER_SRC" ]; then
    cecho "${RED}‚ùå Error: Task Tracker source not found at $TRACKER_SRC${NC}"
    exit 1
else
    cecho "${YELLOW}Installing Task Tracker...${NC}"
        # Create directories
        mkdir -p "$TRACKER_DIR/hooks"
        mkdir -p "$TRACKER_DIR/services"

        # Copy hook scripts
        cp "$TRACKER_SRC/hooks/utils.py" "$TRACKER_DIR/hooks/"
        cp "$TRACKER_SRC/hooks/goal_tracker.py" "$TRACKER_DIR/hooks/"
        cp "$TRACKER_SRC/hooks/progress_tracker.py" "$TRACKER_DIR/hooks/"
        cp "$TRACKER_SRC/hooks/notification_tracker.py" "$TRACKER_DIR/hooks/"
        cp "$TRACKER_SRC/hooks/snapshot_hook.py" "$TRACKER_DIR/hooks/"
        cp "$TRACKER_SRC/hooks/session_cleanup.py" "$TRACKER_DIR/hooks/"
        cp "$TRACKER_SRC/hooks/session_init.py" "$TRACKER_DIR/hooks/"
        cp "$TRACKER_SRC/hooks/__init__.py" "$TRACKER_DIR/hooks/" 2>/dev/null || touch "$TRACKER_DIR/hooks/__init__.py"

        # Make hooks executable
        chmod +x "$TRACKER_DIR/hooks/"*.py

        # Copy service modules
        cp "$TRACKER_SRC/__init__.py" "$TRACKER_DIR/"
        cp "$TRACKER_SRC/services/__init__.py" "$TRACKER_DIR/services/"
        cp "$TRACKER_SRC/services/database.py" "$TRACKER_DIR/services/"
        cp "$TRACKER_SRC/services/summary_service.py" "$TRACKER_DIR/services/"
        cp "$TRACKER_SRC/services/notification.py" "$TRACKER_DIR/services/"
        cp "$TRACKER_SRC/services/notification_formatter.py" "$TRACKER_DIR/services/"

        # Initialize database
        python3 -c "
import sys
sys.path.insert(0, '$TRACKER_DIR')
from services.database import init_database
init_database()
" 2>/dev/null && cecho "${GREEN}‚úÖ Task Tracker installed${NC}" || {
            cecho "${YELLOW}‚ö†Ô∏è Database init failed, but files installed${NC}"
        }

        # === AI Summary Setup ===
        cecho "\n${BLUE}--- AI Summary Setup ---${NC}"
        cecho "AI Summary uses a third-party API to generate intelligent task summaries."
        cecho "If disabled, notifications will show raw user prompts directly."
        echo ""

        printf "Enable AI Summary? (requires API key) [y/N]: "
        read enable_summary
        enable_summary=${enable_summary:-N}

        TRACKER_CONFIG="$TRACKER_DIR/config.json"

        if [ "$enable_summary" = "Y" ] || [ "$enable_summary" = "y" ]; then
            printf "  API Base URL (e.g. https://api.openai.com/v1): "
            read summary_base_url
            printf "  API Key: "
            read summary_api_key
            printf "  Model (default: gpt-3.5-turbo): "
            read summary_model
            summary_model=${summary_model:-gpt-3.5-turbo}

            if [ -n "$summary_api_key" ]; then
                # Generate config with AI summary enabled
                python3 << PYEOF
import json
config = {
    "summary": {
        "provider": "third_party",
        "third_party": {
            "enabled": True,
            "base_url": "$summary_base_url",
            "api_key": "$summary_api_key",
            "model": "$summary_model",
            "max_tokens": 500
        }
    },
    "notification": {"enabled": True, "show_progress": True}
}
with open("$TRACKER_CONFIG", "w") as f:
    json.dump(config, f, indent=2)
print("‚úÖ AI Summary enabled")
PYEOF
            else
                cecho "${YELLOW}‚ö†Ô∏è No API key provided, using raw display mode${NC}"
            fi
        else
            # Generate config with AI summary disabled
            python3 << PYEOF
import json
config = {
    "summary": {
        "provider": "disabled",
        "disabled": True
    },
    "notification": {"enabled": True, "show_progress": True}
}
with open("$TRACKER_CONFIG", "w") as f:
    json.dump(config, f, indent=2)
print("‚úÖ AI Summary disabled (raw display mode)")
PYEOF
        fi
fi

# ================= Generate Shell Config =================
cecho "${YELLOW}Generating Shell Integration...${NC}"

cat << EOF > "$CONFIG_FILE"
# Claude Monitor Configuration
# Auto-generated by install.sh

_CLAUDE_MON_APP="$BINARY_PATH"
_CLAUDE_API_MANAGER="$API_MANAGER_SCRIPT"
_CLAUDE_ACCOUNT_MANAGER="$ACCOUNT_MANAGER_SCRIPT"
_CLAUDE_HOOKS_DIR="$BASE_DIR"

# --- API Management Command ---
function claude-api() {
    python3 "\$_CLAUDE_API_MANAGER" "\$@"
}

# --- Account Management Command ---
function claude-ac() {
    python3 "\$_CLAUDE_ACCOUNT_MANAGER" "\$@"
    if [ "\$1" = "add" ] || [ "\$1" = "rm" ]; then
        echo "üí° Run: source ~/.zshrc to apply changes"
    fi
}

# --- Core Smart Wrapper ---
_claude_wrapper() {
    local account_alias="\$1"
    local config_path="\$2"
    shift 2

    # 1. Detect Window IMMEDIATELY (before any processing)
    local detected_info=\$("\$_CLAUDE_MON_APP" detect 2>/dev/null)
    local detected_bundle=\$(echo "\$detected_info" | cut -d'|' -f1)
    local detected_pid=\$(echo "\$detected_info" | cut -d'|' -f2)
    local detected_window_id=\$(echo "\$detected_info" | cut -d'|' -f3)

    # 2. Generate pending session ID (UUID)
    local pending_id=\$(uuidgen | tr '[:upper:]' '[:lower:]')

    # 3. Parse Arguments
    local -a claude_args
    local api_profile=""

    while [[ \$# -gt 0 ]]; do
        key="\$1"
        case \$key in
            --api)
                api_profile="\$2"
                shift 2
                ;;
            --api=*)
                api_profile="\${key#*=}"
                shift 1
                ;;
            *)
                claude_args+=("\$1")
                shift 1
                ;;
        esac
    done

    # 4. Execute in Subshell (API env isolation only)
    (
        if [ -n "\$api_profile" ]; then
            eval "\$(python3 "\$_CLAUDE_API_MANAGER" get-env "\$api_profile")"
            echo "üöÄ API Profile Active: \$api_profile"
        fi

        export CLAUDE_TERM_BUNDLE_ID="\${detected_bundle:-com.apple.Terminal}"
        export CLAUDE_TERM_PID="\${detected_pid:-0}"
        export CLAUDE_CG_WINDOW_ID="\${detected_window_id:-0}"
        export CLAUDE_CONFIG_DIR="\$config_path"
        export CLAUDE_ACCOUNT_ALIAS="\$account_alias"
        export CLAUDE_PENDING_SESSION_ID="\$pending_id"

        # Create pending session BEFORE starting Claude (shows 'idle' in status bar)
        python3 "\$_CLAUDE_HOOKS_DIR/task_tracker/hooks/session_init.py" 2>/dev/null

        command claude "\${claude_args[@]}"
    )

    # 5. Cleanup on exit (handles ctrl+c and normal exit)
    # Pass pending_id as argument to only cleanup this specific session
    (set +m; python3 "\$_CLAUDE_HOOKS_DIR/task_tracker/hooks/session_cleanup.py" "\$pending_id" >/dev/null 2>&1 &)
}
EOF

# ================= 4. Account Setup =================
cecho "${YELLOW}[4/7] Setting up Claude accounts...${NC}"

# Use space-separated lists (sh compatible)
account_aliases=""
account_paths=""

# Auto-detect existing accounts from config.sh
if [ -f "$CONFIG_FILE" ]; then
    cecho "${YELLOW}[!] Detected existing configuration${NC}"
    while IFS= read -r line; do
        case "$line" in
            alias\ *=\'_claude_wrapper*)
                alias_name=$(echo "$line" | sed 's/alias[[:space:]]*\([^=]*\)=.*/\1/' | tr -d ' ')
                config_path=$(echo "$line" | sed "s/.*_claude_wrapper \"\([^\"]*\)\" \"\([^\"]*\)\".*/\2/")
                account_aliases="${account_aliases:+$account_aliases }$alias_name"
                account_paths="$account_paths|$config_path"
                cecho "  Found: ${GREEN}$alias_name${NC} -> $config_path"
                ;;
        esac
    done < "$CONFIG_FILE"
fi

# Interactive Wizard
cecho "\n${BLUE}--- Account Setup Wizard ---${NC}"

# Check if default account already exists
has_default=0
if echo " $account_aliases " | grep -q " c "; then
    has_default=1
    cecho "DEFAULT account ${GREEN}'c'${NC} already configured"
    printf "Keep it? [Y/n]: "
    read keep_default
    keep_default=${keep_default:-Y}
    if [ "$keep_default" = "n" ] || [ "$keep_default" = "N" ]; then
        account_aliases=$(echo "$account_aliases" | sed 's/ c//' | sed 's/^c //' | sed 's/^c$//')
        has_default=0
    fi
fi

if [ $has_default -eq 0 ]; then
    printf "Enter alias for DEFAULT account (default 'c'): "
    read def_alias
    def_alias=${def_alias:-c}
    if ! echo " $account_aliases " | grep -q " $def_alias "; then
        account_aliases="${account_aliases:+$account_aliases }$def_alias"
        account_paths="${account_paths}|$HOME/.claude"
    fi
else
    def_alias="c"
fi

# Additional accounts loop
while true; do
    printf "Add another account? (y/N): "
    read yn
    case $yn in
        [Yy]* )
            # Input alias with validation
            while true; do
                printf "Alias Name (e.g. cw): "
                read a_alias
                if [ -z "$a_alias" ]; then
                    cecho "${RED}‚ùå Alias name cannot be empty${NC}"
                    continue
                fi
                if echo " $account_aliases " | grep -q " $a_alias "; then
                    cecho "${YELLOW}‚ö†Ô∏è  Alias '$a_alias' already exists${NC}"
                    printf "Overwrite? (y/n): "
                    read overwrite
                    if [ "$overwrite" = "y" ] || [ "$overwrite" = "Y" ]; then
                        account_aliases=$(echo "$account_aliases" | sed "s/ $a_alias//" | sed "s/^$a_alias //" | sed "s/^$a_alias$//")
                        break
                    fi
                else
                    break
                fi
            done

            # Input config path with smart default
            smart_default_path="$HOME/.claude-$a_alias"
            while true; do
                printf "Config Path [Default: ${GREEN}$smart_default_path${NC}]: "
                read a_path
                if [ -z "$a_path" ]; then
                    a_path_expanded="$smart_default_path"
                else
                    case "$a_path" in
                        \~/*) a_path_expanded="$HOME${a_path#\~}" ;;
                        *) a_path_expanded="$a_path" ;;
                    esac
                fi
                if [ ! -d "$a_path_expanded" ]; then
                    cecho "${YELLOW}‚ö†Ô∏è  Path does not exist: $a_path_expanded${NC}"
                    printf "Create it? (Y/n): "
                    read create_dir
                    create_dir=${create_dir:-Y}
                    if [ "$create_dir" = "y" ] || [ "$create_dir" = "Y" ]; then
                        mkdir -p "$a_path_expanded"
                        cecho "${GREEN}‚úÖ Created directory${NC}"
                        break
                    fi
                else
                    break
                fi
            done

            account_aliases="${account_aliases:+$account_aliases }$a_alias"
            account_paths="$account_paths|$a_path_expanded"
            cecho "${GREEN}‚úÖ Added: $a_alias -> $a_path_expanded${NC}"
            ;;
        * ) break;;
    esac
done

# Use Python to generate accounts.json and append aliases to config.sh
cecho "\n${YELLOW}Writing account configuration...${NC}"

ACCOUNT_ALIASES="$account_aliases" \
ACCOUNT_PATHS="$account_paths" \
CONFIG_FILE="$CONFIG_FILE" \
ACCOUNTS_JSON="$BASE_DIR/accounts.json" \
python3 << 'PYEOF'
import os
import json

aliases = os.environ.get('ACCOUNT_ALIASES', '').split()
paths = os.environ.get('ACCOUNT_PATHS', '').split('|')[1:]  # Skip first empty element
config_file = os.environ['CONFIG_FILE']
accounts_json = os.environ['ACCOUNTS_JSON']

if len(aliases) != len(paths):
    print(f"‚ùå Mismatch: {len(aliases)} aliases vs {len(paths)} paths")
    exit(1)

# Build accounts dict
accounts = {}
for alias, path in zip(aliases, paths):
    if alias and path:
        accounts[alias] = path

# Write accounts.json
with open(accounts_json, 'w') as f:
    json.dump(accounts, f, indent=2)
print(f"‚úÖ Generated {accounts_json}")

# Append aliases to config.sh
with open(config_file, 'a') as f:
    f.write("\n# --- User Aliases ---\n")
    for alias, path in accounts.items():
        f.write(f'alias {alias}=\'_claude_wrapper "{alias}" "{path}"\'\n')
        print(f"   Registered: {alias}")

exit(0)
PYEOF

if [ $? -ne 0 ]; then
    cecho "${RED}‚ùå Failed to generate account configuration${NC}"
    exit 1
fi

# Store first alias for usage example
first_alias=$(echo "$account_aliases" | awk '{print $1}')
first_alias=${first_alias:-c}

# ================= 5. API Profiles Setup =================
cecho "\n${BLUE}--- API Profiles Setup ---${NC}"
cecho "Add API profiles for third-party providers (Kimi, Qwen, DeepSeek, etc.)"
cecho "Usage: ${GREEN}c --api <profile_name>${NC}"
echo ""

while true; do
    printf "Add an API profile? (y/N): "
    read setup_api
    case $setup_api in
        [Yy]* ) ;;
        * ) break;;
    esac

    printf "Profile Name (e.g. kimi, qwen): "
    read api_name
    [ -z "$api_name" ] && continue

    env_vars=""

    # === Standard Environment Variables (prompt for values directly) ===
    cecho "\n${YELLOW}=== Standard Environment Variables ===${NC}"

    printf "  ANTHROPIC_BASE_URL (API endpoint): "
    read val_url
    [ -n "$val_url" ] && env_vars="$env_vars ANTHROPIC_BASE_URL=$val_url"

    printf "  ANTHROPIC_API_KEY (API key): "
    read val_key
    [ -n "$val_key" ] && env_vars="$env_vars ANTHROPIC_API_KEY=$val_key"

    printf "  ANTHROPIC_MODEL (model name, optional): "
    read val_model
    [ -n "$val_model" ] && env_vars="$env_vars ANTHROPIC_MODEL=$val_model"

    # === Custom Environment Variables ===
    cecho "\n${YELLOW}=== Custom Environment Variables (optional) ===${NC}"
    cecho "Format: ${GREEN}KEY=VALUE${NC}, type ${GREEN}done${NC} to finish"

    while true; do
        printf "  > "
        read env_input
        case $env_input in
            done|DONE|Done) break;;
            *=*) env_vars="$env_vars $env_input";;
            "") break;;
            *) cecho "${RED}  Invalid format. Use KEY=VALUE or 'done'${NC}";;
        esac
    done

    if [ -n "$env_vars" ]; then
        python3 "$API_MANAGER_SCRIPT" add "$api_name" $env_vars
    else
        cecho "${YELLOW}No variables added for $api_name${NC}"
    fi
done

# ================= 6. Configure Claude Hooks Integration =================
cecho "\n${YELLOW}[6/7] Configuring Claude Hooks...${NC}"
cecho "Mode: ${GREEN}Task Tracker${NC} (unified architecture)"
cecho "This will enable real-time notifications (idle alerts, permission prompts, etc.)"
echo ""

# Iterate over accounts
idx=0
for alias_name in $account_aliases; do
    [ -z "$alias_name" ] && continue
    idx=$((idx + 1))

    # Extract the idx-th path from account_paths
    IFS='|'
    path_idx=0
    config_path=""
    for path in $account_paths; do
        path_idx=$((path_idx + 1))
        if [ $path_idx -eq $((idx + 1)) ]; then  # +1 because paths start with |
            config_path="$path"
            break
        fi
    done
    IFS=' '

    [ -z "$config_path" ] && continue

    # Check if settings.json already exists
    if [ -f "$config_path/settings.json" ]; then
        cecho "${YELLOW}[!] settings.json exists for '$alias_name' ($config_path)${NC}"
    fi

    printf "Configure hooks for '$alias_name' ($config_path)? [Y/n]: "
    read install_hook
    install_hook=${install_hook:-Y}
    if [ "$install_hook" = "Y" ] || [ "$install_hook" = "y" ] || [ -z "$install_hook" ]; then
        generate_hooks_config "$config_path"
    fi
done

# ================= 7. Finalize =================
cecho "\n${YELLOW}[7/7] Configuring Shell Integration...${NC}"

RC_FILE="$HOME/.zshrc"
[ -f "$HOME/.bashrc" ] && RC_FILE="$HOME/.bashrc"

SOURCE_CMD="source \"$CONFIG_FILE\""

# Clean up any duplicate/malformed entries first
if grep -q "Claude Monitor" "$RC_FILE" 2>/dev/null; then
    cecho "${YELLOW}[!] Cleaning up existing Claude Monitor entries...${NC}"
    grep -v "Claude Monitor" "$RC_FILE" | grep -v "$CONFIG_FILE" > "${RC_FILE}.tmp"
    mv "${RC_FILE}.tmp" "$RC_FILE"
fi

# Add fresh configuration if not present
if ! grep -q "$CONFIG_FILE" "$RC_FILE" 2>/dev/null; then
    echo "" >> "$RC_FILE"
    echo "# Claude Monitor Hooks" >> "$RC_FILE"
    echo "$SOURCE_CMD" >> "$RC_FILE"
fi
cecho "${GREEN}‚úÖ Shell configuration updated${NC}"

[ -z "$first_alias" ] && first_alias="c"

# ================= Summary =================
cecho "\n${GREEN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
cecho "${GREEN}‚ïë     üéâ Installation Complete! üéâ             ‚ïë${NC}"
cecho "${GREEN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
echo ""

cecho "${BLUE}üì¶ Êû∂ÊûÑ:${NC} ${GREEN}Task Tracker (Áªü‰∏ÄÊû∂ÊûÑ)${NC}"
cecho "   ÂäüËÉΩ: ËøõÂ∫¶ËøΩË∏™, ÁõÆÊ†áËøΩË∏™, ÂØåÊñáÊú¨ÈÄöÁü•, ‰ºöËØùÂø´ÁÖß"
echo ""

cecho "${BLUE}üìã Configured Accounts:${NC}"
idx=0
for alias_name in $account_aliases; do
    [ -z "$alias_name" ] && continue
    idx=$((idx + 1))
    IFS='|'
    path_idx=0
    for path in $account_paths; do
        path_idx=$((path_idx + 1))
        if [ $path_idx -eq $((idx + 1)) ]; then
            cecho "   ${GREEN}$alias_name${NC} ‚Üí $path"
            break
        fi
    done
    IFS=' '
done
echo ""

cecho "${YELLOW}üìù Next Steps:${NC}"
cecho "   1. Run: ${GREEN}source $RC_FILE${NC}"
cecho "   2. Test: ${GREEN}$first_alias${NC} (or any configured alias)"
cecho "   3. Settings: ${GREEN}$BINARY_PATH gui${NC}"
cecho "   4. Logs: ${BLUE}~/.claude-task-tracker/logs/${NC}"
cecho "   5. Config: ${BLUE}~/.claude-task-tracker/config.json${NC}"
echo ""

cecho "${BLUE}üìã Management Commands:${NC}"
cecho "   ${GREEN}claude-api list${NC}      - List all API profiles"
cecho "   ${GREEN}claude-api add${NC}       - Add new API profile"
cecho "   ${GREEN}claude-api rm${NC}        - Remove API profile"
cecho "   ${GREEN}claude-ac add${NC}        - Add new account"
cecho "   ${GREEN}claude-ac list${NC}       - List all accounts"
echo ""

cecho "${YELLOW}‚ö†Ô∏è  Automation Permission (for minimized window restore):${NC}"
cecho "   If notification click doesn't restore minimized windows:"
cecho "   ${BLUE}System Preferences > Privacy & Security > Privacy > Automation${NC}"
cecho "   Allow ${GREEN}ClaudeMonitor${NC} to control ${GREEN}System Events${NC}"
echo ""

cecho "${BLUE}üí° Tip: Run this script again to add/modify accounts or change installation mode${NC}"